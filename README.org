#+AUTHOR: Anthony Kalaitzis
#+EMAIL: anthony.kalaitzis@gmail.com
#+TITLE: numFort

* Description
numFort is a numerical library for FORTRAN that includes quadpack, lapack and PLplot source code. It enables the use of handy mathematical macros such as linspace. I have wasted so much of my life on this nonsense. 

* Installation - Linux/Unix
** ifort
- Before using numFort, make sure to download the ifort compiler and the necessary math kernel libraries for the use of LAPACK. These may be downloaded from the following link (free for students) [[https://software.intel.com/en-us/qualify-for-free-software/student][Parallel studio XE]], click the C++ link unless on mac
- Simply download the custom install, extract to a location and run under sudo privileges like so
#+BEGIN_SRC shell
  sudo ./install.sh
#+END_SRC
- Make sure to check the math kernel for install
- After installation you may need to export the path to the *ifort* compiler. Add code similar to below in your ~/.bashrc. Your exact path for the above libraries might be different (probably just different numbers for 2018.3.222)
#+BEGIN_SRC shell
  source /opt/intel/bin/compilervars.sh intel64
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/intel/compilers_and_libraries_2018.3.222/linux/mkl/lib/intel64_lin/
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/intel/compilers_and_libraries_2018.3.222/linux/compiler/lib/intel64_lin/
#+END_SRC
- Close and open the terminal to refresh
- Check that it's working by typing
#+BEGIN_SRC shell
  ifort --version
#+END_SRC
- Your ifort version should display
** Cmake
- Download Cmake source code for linux from the following link [[https://cmake.org/download/][CMAKE]]
- Extract the Cmake folder and then open a terminal and move inside
- Type the following commands to install Cmake
#+BEGIN_SRC shell
  ./bootstrap
  sudo make
  sudo make install
#+END_SRC
- Check the installation was successful by opening and closing the terminal, and then typing
#+BEGIN_SRC shell
  cmake --version
#+END_SRC
- This should print a value for your working version of CMAKE. You may have to close and open the terminal to refresh
** PLplot
- Open up a terminal in your home directory. For this example we will install in a folder called ~/bin (/home/user/bin). The following commands downloads the necessary code
#+BEGIN_SRC shell
  mkdir bin
  cd bin
  git clone git://git.code.sf.net/p/plplot/plplot plplot.git
#+END_SRC
- This will download the source code and put it into a folder. Ours will be called PLplotSrc, you may rename yours to this if you wish
- Before continuing we will need to add some path variables in our ~/.bashrc, open ~/.bashrc and write the following. This will tell PLplot to use the ifort compiler (This should be the path to the ifort compiler i.e. where ever you installed it)
#+BEGIN_SRC shell
  export FC=/opt/intel/bin/ifort
#+END_SRC
- Back inside our ~/bin folder with our PLplotSrc sub directory, make the following directories 
#+BEGIN_SRC shell
  mkdir buildDir
  mkdir installDir
  cd buildDir
#+END_SRC
- Just in case, copy the file CMakeLists.txt into your buildDir directory which should be located in PLplotSrc
- We are now going to run the CMAKE command which has the following syntax 
- *MAKE SURE* you run this command whilst in the buildDir and *NOT* PLplotSrc or installDir
#+BEGIN_SRC shell
  cmake -DCMAKE_INSTALL_PREFIX=/path/to/installDir /path/to/PLplotSrc
#+END_SRC
- After the command finishes run the following
#+BEGIN_SRC shell
  make 
  sudo make install
#+END_SRC
- This should take a bit but whens its done you're almost finished!
- This should have filled your installDir with lovely source code. Now simply add the following to your ~/.bashrc (Double check the final files names as they may change with versions of PLplot
#+BEGIN_SRC shell
  export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:~/bin/installDir/lib/pkgconfig/
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/bin/installDir/lib/
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/bin/buildDir/bindings/fortran/
#+END_SRC
- Open and close the terminal, that should be everything

** NumFort
- Download and move numFort repository files to specified location eg. /path/to/numFort
- Your final makefile should look something like this
#+BEGIN_SRC shell
  # Fortran base MakeFile
# Directory to numFort
DIR = /path/to/numFort

F90C = ifort
F90FLAGS = -O2
CFLAGS = -O2 -xHost -mkl

PLPLOT = $$(pkg-config --cflags --libs plplot-fortran)
LIBS = -lmkl_lapack95_lp64 -lplplotfortran -lplplot 
MYLIBS = -I$(DIR)

%.o: %.f90
	$(F90C) $(CFLAGS) -c $<

# Library object files
LIBOBJS = $(DIR)lapack.o\
	$(DIR)numFort.o

# Own personal object files
OBJS = 

all: filename

filename: filename.f90 
	$(F90C) $(CFLAGS) -o $@ $< $(OBJS) $(LIBOBJS) $(LIBS) $(PLPLOT) $(MYLIBS)

clean:
	rm *.o *.mod
#+END_SRC
- *SOME IMPORTANT NOTES ON THE ABOVE MAKEFILE*

- for the PLPLOT variable, plplot-fortran is the name of the pkg-config FORTRAN file located in installDir/lib/pkgconfig. It may have a different name for you (In this case for us it is called plplot-fortran.pc)

- DIR is the directory where you have put all the numFort source code

- The bash file /recompile.sh/ in the repository can be used to recompile these libraries if you should choose to edit and add. Simply run with ./recompile.sh whilst in the directory. Alternatively one may run the following command in the terminal

#+BEGIN_SRC shell
  (cd /path/to/numFort/; ./recompile.sh)
#+END_SRC

- Include your own module files under the variable *OBJS*. Bonza, you should be ready to go

* Documentation
The two modules you may include are /kinds/ and /numFort/. Simply include in any .f90 file via a simple use statement as per usual. 
#+BEGIN_SRC fortran
  program progName
        use kinds
        use numFort

        ...

  end progName
#+END_SRC
Below we will give short descriptions of the module files and the subroutines and functions contained inside.

Make sure to search for these functions inside numFort to see their parameters. A brief description of their parameters are listed below for _ALL_ possible routine variants.

** Kinds
Precision parameter file. Main uses are for constants like pi and making variables double precision.

** NumFort

*** Factorial
Calculates the factorial of n

|-----------+---------------------|
| Variable  | Description         |
|-----------+---------------------|
| n         | integer             |
|-----------+---------------------|
| factorial | outputted factorial |
|-----------+---------------------|

*** Meshgrid
Creates a unique lattice of points for two given vectors x and y. Usually used for making a 3D grid for 3 dimensional plots.

|----------+---------------------------------------|
| Variable | Description                           |
|----------+---------------------------------------|
| x        | double precision vector               |
| y        | double precision vector               |
|----------+---------------------------------------|
| XX       | matrix of dimension (size(y),size(x)) |
| YY       | matrix of dimension (size(y),size(x)) |
|----------+---------------------------------------|


*** Splinefit
Fits a cubic spline to inputted data. This function can return the coefficients or just a list of desired points to be interpolated at.

|----------+------------------------------------------|
| Variable | Description                              |
|----------+------------------------------------------|
| x        | double precision vector                  |
| y        | double precision vector                  |
| xj       | this is the vector x for calculation use |
| intpts   | points to interpolate at (vector)        |
|----------+------------------------------------------|
| intvals  | outputted interpolant values             |
| c        | coefficients for spline fit              |
|----------+------------------------------------------|

*** PolyFit
Exactly the same as SplineFit but for a Nth order polynomial.

|----------+----------------------------------|
| Variable | Description                      |
|----------+----------------------------------|
| N        | integer, order of polynomial     |
| x        | double precision vector          |
| y        | double precision vector          |
|----------+----------------------------------|
| c        | coefficient of fit               |
| x        | value to calculate polynomial at |
|----------+----------------------------------|

*** rk4
Performs a 4th order Runge Kutta solving algorithm for a given DE. Algorithms giving for a single DE or 2 coupled DE. May have this method go over a range of points or just a single step.

|----------+----------------------------------------|
| Variable | Description                            |
|----------+----------------------------------------|
| t0       | initial value to start stepping at     |
| tN       | final value to step to                 |
| y0       | initial y value                        |
| N        | total number of points to step through |
| f        | input function                         |
| h        | step size                              |
|----------+----------------------------------------|
| x        | value to calculate polynomial at       |
| t        | outputted x values                     |
| y        | outputted y values                     |
|----------+----------------------------------------|

*** GuessZero
Given a set of values or a function with boundaries, returns the approximate value of where the function changes sign. An index is returned for inputted values method and the x value exactly is returned for the function method.

|-----------+---------------------------------|
| Variable  | Description                     |
|-----------+---------------------------------|
| f         | input function                  |
| fvals     | list of y values for a function |
| a,b       | range for zero guess            |
|-----------+---------------------------------|
| GuessZero | integer index of zero location  |
|-----------+---------------------------------|

*** Newton1D
Performs a 1 dimensional newtons method to find the zero of a function.

|----------+---------------------------------------|
| Variable | Description                           |
|----------+---------------------------------------|
| fn       | Input function                        |
| guess    | initial guess of zero of the function |
|----------+---------------------------------------|
| newton1D | zero of function guess location       |
|----------+---------------------------------------|

*** Linspace
Creates a linear space of points between a and b with N points.

|----------+----------------------------------|
| Variable | Description                      |
|----------+----------------------------------|
| start    | left bound                       |
| finish   | right bound                      |
| N        | number of points, integer        |
|----------+----------------------------------|
| linspace | vector of points between a and b |
|----------+----------------------------------|

*** Deriv
Numerically calculates the derivative via a centred finite difference method.

|----------+-------------------------------|
| Variable | Description                   |
|----------+-------------------------------|
| f        | Input function                |
| x0       | value to calculate            |
|----------+-------------------------------|
| deriv    | value of numerical derivative |
|----------+-------------------------------|

*** integral
Numerically calculates an integral given a function and bounds. Using Gaussin quadrature.

|----------+-----------------------------|
| Variable | Description                 |
|----------+-----------------------------|
| f        | Input function              |
| a        | left bound                  |
| b        | right bound                 |
| absErr   | absolute error              |
| relErr   | relative error              |
|----------+-----------------------------|
| integral | numerical value of integral |
|----------+-----------------------------|

** PLplot

Call PLplot by using the subroutine plot() for example, this will call various wrappers to plplot which can be found within numFort. Below is a list of said wrappers and their arguments. Axes labels and title may be omitted in all below routines if one wishes.

*** plot
Can be called in the two following ways
#+BEGIN_SRC fortran
  real(DP),dimension(N,M) :: data ! x values in columns 1,3,.. y values in 2,4,...
  real(DP),dimension(N)   :: x,y
  character(len=*)        :: xlabel,ylabel,title

  call plot(x,y,xlabel,ylabel,title)
  call plot(data,xlabel,ylabel,title)
#+END_SRC
produces a standard x vs y plot. 

*** scatterplot
Can be called in the two following ways
#+BEGIN_SRC fortran
  real(DP),dimension(N)   :: x,y
  character(len=*)        :: xlabel,ylabel,title,style ! style = "+" for example

  call scatterplot(x,y,style,xaxis,yaxis,title)
#+END_SRC
produces a standard scatter plot of x vs y.

*** surf
Can be called in the two following ways
#+BEGIN_SRC fortran
  real(DP),dimension(N)   :: X
  real(DP),dimension(M)   :: Y
  real(DP),dimension(M,N) :: Z
  character(len=*)        :: xlabel,ylabel,zlabel,title

  ! usually create the grids for Z using "call meshgrid(x,y,XX,YY)"
  ! XX = MxN and YY = MxN

  call surf(X,Y,Z,xlabel,ylabel,zlabel,title)
#+END_SRC


*** scatter3D
Can be called in the two following ways
#+BEGIN_SRC fortran
  real(DP),dimension(N)   :: x,y,z
  character(len=*)        :: xlabel,ylabel,zlabel,title

 call scatter3D(X,Y,Z,xlabel,ylabel,zlabel,title)
#+END_SRC
