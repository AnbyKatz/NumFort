#+AUTHOR: Anthony Kalaitzis
#+EMAIL: anthony.kalaitzis@gmail.com
#+TITLE: numFort

* Description
numFort is a numerical library for FORTRAN that includes quadpack, lapack and PLplot source code. It enables the use of handy mathematical macros such as linspace. I have wasted so much of my life on this nonsense.

* Installation - Linux/Unix
** ifort
- Before using numFort, make sure to download the ifort compiler and the necessary math kernel libraries for the use of LAPACK. These may be downloaded from the following link (free for students) [[https://software.intel.com/en-us/qualify-for-free-software/student][Parallel studio XE]], click the C++ link unless on mac
- Simply download the custom install, extract to a location and run under sudo privileges like so
#+BEGIN_SRC shell
  sudo ./install.sh
#+END_SRC
- Make sure to check the math kernel for install
- After installation you may need to export the path to the *ifort* compiler. Add code similar to below in your ~/.bashrc. Your exact path for the above libraries might be different (probably just different numbers for 2018.3.222)
#+BEGIN_SRC shell
  source /opt/intel/bin/compilervars.sh intel64
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/intel/compilers_and_libraries_2018.3.222/linux/mkl/lib/intel64_lin/
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/intel/compilers_and_libraries_2018.3.222/linux/compiler/lib/intel64_lin/
#+END_SRC
- Close and open the terminal to refresh
- Check that it's working by typing
#+BEGIN_SRC shell
  ifort --version
#+END_SRC
- Your ifort version should display
** Cmake
- Download Cmake source code for linux from the following link [[https://cmake.org/download/][CMAKE]]
- Extract the Cmake folder and then open a terminal and move inside
- Type the following commands to install Cmake
#+BEGIN_SRC shell
  ./bootstrap
  sudo make
  sudo make install
#+END_SRC
- Check the installation was successful by opening and closing the terminal, and then typing
#+BEGIN_SRC shell
  cmake --version
#+END_SRC
- This should print a value for your working version of CMAKE. You may have to close and open the terminal to refresh
** PLplot
- Open up a terminal in your home directory. For this example we will install in a folder called ~/bin (/home/user/bin). The following commands downloads the necessary code
#+BEGIN_SRC shell
  mkdir bin
  cd bin
  git clone git://git.code.sf.net/p/plplot/plplot plplot.git
#+END_SRC
- This will download the source code and put it into a folder. Ours will be called PLplotSrc, you may rename yours to this if you wish
- Before continuing we will need to add some path variables in our ~/.bashrc, open ~/.bashrc and write the following. This will tell PLplot to use the ifort compiler (This should be the path to the ifort compiler i.e. where ever you installed it)
#+BEGIN_SRC shell
  export FC=/opt/intel/bin/ifort
#+END_SRC
- Back inside our ~/bin folder with our PLplotSrc sub directory, make the following directories
#+BEGIN_SRC shell
  mkdir buildDir
  mkdir installDir
  cd buildDir
#+END_SRC
- Just in case, copy the file CMakeLists.txt into your buildDir directory which should be located in PLplotSrc
- We are now going to run the CMAKE command which has the following syntax
- *MAKE SURE* you run this command whilst in the buildDir and *NOT* PLplotSrc or installDir
#+BEGIN_SRC shell
  cmake -DCMAKE_INSTALL_PREFIX=/path/to/installDir /path/to/PLplotSrc
#+END_SRC
- After the command finishes run the following
#+BEGIN_SRC shell
  make
  sudo make install
#+END_SRC
- This should take a bit but whens its done you're almost finished!
- This should have filled your installDir with lovely source code. Now simply add the following to your ~/.bashrc (Double check the final files names as they may change with versions of PLplot
#+BEGIN_SRC shell
  export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:~/bin/installDir/lib/pkgconfig/
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/bin/installDir/lib/
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/bin/buildDir/bindings/fortran/
#+END_SRC
- Open and close the terminal, that should be everything

** NumFort
- Download and move numFort repository files to specified location eg. /path/to/numFort
- Your final makefile should look something like this
#+BEGIN_SRC shell
# Fortran base MakeFile
# Directory to numFort
DIR = /path/to/numFort/

F90C = ifort
F90FLAGS = -O2
CFLAGS = -O2 -mkl

PLPLOT = $$(pkg-config --cflags --libs plplot-fortran)
LIBS = -lmkl_lapack95_lp64 -lplplotfortran -lplplot 
MYLIBS = -I$(DIR)

%.o: %.f90
	$(F90C) $(CFLAGS) -c $<

# Library object files
LIBOBJS = $(DIR)lapack.o\
	$(DIR)numFort.o

# Own personal object files
OBJS = 

all: filename

filename: filename.f90 $(OBJS)
	$(F90C) $(CFLAGS) -o $@ $< $(OBJS) $(LIBOBJS) $(LIBS) $(PLPLOT) $(MYLIBS)

clean:
	rm *.o *.mod
#+END_SRC
- *SOME IMPORTANT NOTES ON THE ABOVE MAKEFILE*

- for the PLPLOT variable, plplot-fortran is the name of the pkg-config FORTRAN file located in installDir/lib/pkgconfig. It may have a different name for you (In this case for us it is called plplot-fortran.pc)

- DIR is the directory where you have put all the numFort source code

- The bash file /recompile.sh/ in the repository can be used to recompile these libraries if you should choose to edit and add. Simply run with ./recompile.sh whilst in the directory. Alternatively one may run the following command in the terminal

#+BEGIN_SRC shell
  (cd /path/to/numFort/; ./recompile.sh)
#+END_SRC

- Include your own module files under the variable *OBJS*. Bonza, you should be ready to go

* Documentation
The two modules you may include are /kinds/ and /numFort/. Simply include in any .f90 file via a simple use statement as per usual.
#+BEGIN_SRC fortran
  program progName
        use kinds
        use numFort

        ...

  end progName
#+END_SRC
Below we will give short descriptions of the module files and the subroutines and functions contained inside.

Listed variables (some may be optional) and examples of how to call:

** Kinds
Precision parameter file. Main uses are for constants like pi and making variables double precision.

** NumFort

*** bessel
Calculate the value of the 0<n<3 order bessel fucntion at x

|----------+------------------------------|
| Variable | Description                  |
|----------+------------------------------|
| n        | integer, order of bessel     |
| x        | real double precision        |
|----------+------------------------------|
| bessel   | value of the bessel function |
|----------+------------------------------|

#+BEGIN_SRC fortran
  value = bessel(x,n)
#+END_SRC
*** Trace
Calculate the trace of a matrix

|----------+-----------------------------------------------|
| Variable | Description                                   |
|----------+-----------------------------------------------|
| M(N,N)   | Matrix, SP or DP for real or complex matrices |
|----------+-----------------------------------------------|
| Trace    | Same type as input matrix                     |
|----------+-----------------------------------------------|

#+BEGIN_SRC fortran
  value = trace(M)
#+END_SRC

*** Factorial
Calculates the factorial of n

|-----------+---------------------|
| Variable  | Description         |
|-----------+---------------------|
| n         | integer             |
|-----------+---------------------|
| factorial | outputted factorial |
|-----------+---------------------|

#+BEGIN_SRC fortran
  m = factorial(n)
#+END_SRC

*** Meshgrid
Creates a unique lattice of points for two given vectors x and y. Usually used for making a 3D grid for 3 dimensional plots.

|----------+-------------------------|
| Variable | Description             |
|----------+-------------------------|
| x(N)     | double precision vector |
| y(M)     | double precision vector |
|----------+-------------------------|
| XX(M,N)  | double precision matrix |
| YY(M,N)  | double precision matrix |
|----------+-------------------------|

#+BEGIN_SRC fortran
  call meshgrid(x,y,XX,YY)
#+END_SRC


*** Splinefit
Fits a cubic spline to inputted data. This function can return the coefficients or just a list of desired points to be interpolated at.

|------------+------------------------------------------|
| Variable   | Description                              |
|------------+------------------------------------------|
| x(N)       | double precision vector                  |
| y(N)       | double precision vector                  |
| xj(N)      | this is the vector x for calculation use |
| intpts(N)  | points to interpolate at (vector)        |
| intvals(N) | outputted interpolant values             |
| c(N)       | coefficients for spline fit              |
| x          | point to evaluate fit at                 |
|------------+------------------------------------------|
| splinevals | output values for fit                    |
|------------+------------------------------------------|

#+BEGIN_SRC fortran
  call splinefit(x,y,intpts,intvals)
  call splinefit(x,y,c)
  ! should be called after splinefit
  value = splinevals(c,xj,x)
#+END_SRC

*** PolyFit
Exactly the same as SplineFit but for a Nth order polynomial.

|----------+----------------------------------|
| Variable | Description                      |
|----------+----------------------------------|
| N        | integer, order of polynomial     |
| x(N)     | double precision vector          |
| y(N)     | double precision vector          |
|----------+----------------------------------|
| c(N+1)   | coefficient of fit               |
| x        | value to calculate polynomial at |
|----------+----------------------------------|

#+BEGIN_SRC fortran
  call polyfit(x,y,N,c)
  ! Should be called after polyfit
  value = polyCal(N,c,x)
#+END_SRC

*** EulerM
Performs Eulers method to solve a single or N coupled DE's, same call notation as rk4

|----------+------------------------------------|
| Variable | Description                        |
|----------+------------------------------------|
| t0       | initial value to start stepping at |
| y0       | initial y value(s)                 |
| f        | input function(s)                  |
| h        | step size                          |
| nEq      | number of coupled equations        |
|----------+------------------------------------|
| rk4      | output (y_{n+1})                   |
|----------+------------------------------------|

#+BEGIN_SRC fortran
  function f(t,y)
  value = eulerM(f,h,t0,y0)

  ! In the N DE case, y = y(N),f = f(N), values = values(N)
  ! i.e. N initial conditions and equations
  function f(t,y,nEq)
  values = eulerM(f,h,t0,y0)
#+END_SRC

*** rk4
Performs a 4th order Runge Kutta solving algorithm for a given DE. Algorithms giving for a single DE or N coupled DE.

|----------+------------------------------------|
| Variable | Description                        |
|----------+------------------------------------|
| t0       | initial value to start stepping at |
| y0       | initial y value(s)                 |
| f        | input function(s)                  |
| h        | step size                          |
| nEq      | number of coupled equations        |
|----------+------------------------------------|
| rk4      | output (y_{n+1})                   |
|----------+------------------------------------|

#+BEGIN_SRC fortran
  function f(t,y)
  value = rk4(f,h,t0,y0)

  ! In the N DE case, y = y(N),f = f(N), values = values(N)
  ! i.e. N initial conditions and equations
  function f(t,y,nEq)
  values = rk4(f,h,t0,y0)
#+END_SRC

*** GuessZero
Given a set of values or a function with boundaries, returns the approximate value of where the function changes sign. An index is returned for inputted values method and the x value exactly is returned for the function method.

|-----------+---------------------------------|
| Variable  | Description                     |
|-----------+---------------------------------|
| f         | input function                  |
| fvals     | list of y values for a function |
| a,b       | range for zero guess            |
|-----------+---------------------------------|
| GuessZero | integer index of zero location  |
|-----------+---------------------------------|

#+BEGIN_SRC fortran
  value = guesszero(fvals)

  function f(x)
  value = guesszero(f,a,b)
#+END_SRC

*** Newton1D
Performs a 1 dimensional newtons method to find the zero of a function.

|----------+---------------------------------------|
| Variable | Description                           |
|----------+---------------------------------------|
| fn       | Input function                        |
| guess    | initial guess of zero of the function |
|----------+---------------------------------------|
| newton1D | zero of function guess location       |
|----------+---------------------------------------|

#+BEGIN_SRC fortran
  function fn(x)
  value = newton1D(fn,x)
#+END_SRC

*** Linspace
Creates a linear space of points between a and b with N points.

|----------+----------------------------------|
| Variable | Description                      |
|----------+----------------------------------|
| start    | left bound                       |
| finish   | right bound                      |
| N        | number of points, integer        |
|----------+----------------------------------|
| linspace | vector of points between a and b |
|----------+----------------------------------|

#+BEGIN_SRC fortran
  vector = linspace(a,b,N)
#+END_SRC

*** Deriv
Numerically calculates the derivative via a centred finite difference method.

|----------+-------------------------------|
| Variable | Description                   |
|----------+-------------------------------|
| f        | Input function                |
| x0       | value to calculate            |
|----------+-------------------------------|
| deriv    | value of numerical derivative |
|----------+-------------------------------|

#+BEGIN_SRC fortran
  function f(x)
  value = deriv(f,x0)
#+END_SRC

*** integral
Numerically calculates an integral given a function and bounds. Using Gaussian quadrature.

|----------+-----------------------------|
| Variable | Description                 |
|----------+-----------------------------|
| f        | Input function              |
| a        | left bound                  |
| b        | right bound                 |
| absErr   | absolute error              |
| relErr   | relative error              |
|----------+-----------------------------|
| integral | numerical value of integral |
|----------+-----------------------------|

#+BEGIN_SRC fortran
  function f(x)
  value = integral(f,a,b,absErr,relErr)
#+END_SRC

*** integralPV
Numerically calculates a Cauchy-Principle value integral using Gaussian quadrature. For a given f(x), evaluates the integral of f(x)/(x-c).

|------------+-----------------------------|
| Variable   | Description                 |
|------------+-----------------------------|
| f          | Input Function              |
| c          | Pole                        |
| a          | Left bound                  |
| b          | Right bound                 |
| absErr     | absolute error              |
| relErr     | relative error              |
|------------+-----------------------------|
| integralPV | numerical value of integral |
|------------+-----------------------------|

#+BEGIN_SRC fortran
  function f(x)
  value = integralPV(f,c,a,b,absErr,relErr)
#+END_SRC

** PLplot

Call PLplot by using the subroutine plot() for example, this will call various wrappers to plplot which can be found within numFort. Below is a list of said wrappers and their arguments. Axes labels and title may be omitted in all below routines if one wishes.

*** plot
standard x vs y plot or even x1,x2,... vs y1,y2,...

|-----------+-------------------------+
| Variable  | Description             |
|-----------+-------------------------+
| x(N)      | x values                |
| y(N)      | y values                |
| data(N,M) | multi-dimensional data  |
| xlabel    | x axis title (optional) |
| ylabel    | y axis title (optional) |
| title     | title (optional)        |
|-----------+-------------------------+

#+BEGIN_SRC fortran
  call plot(x,y,xlabel,ylabel,title)
  call plot(data,xlabel,ylabel,title)
#+END_SRC


*** scatterplot
standard scatter plot
|----------+-------------------------|
| Variable | Description             |
|----------+-------------------------|
| x(N)     | x values                |
| y(N)     | y values                |
| style    | points style e.g. "+"   |
| xlabel   | x axis title (optional) |
| ylabel   | y axis title (optional) |
| title    | title (optional)        |
|----------+-------------------------|

#+BEGIN_SRC fortran
  call scatterplot(x,y,style,xaxis,yaxis,title)
#+END_SRC

*** surf
3D surface plot (goes well with meshgrid)
|----------+-------------------------|
| Variable | Description             |
|----------+-------------------------|
| x(N)     | x values                |
| y(N)     | y values                |
| z(N,N)   | z values                |
| xlabel   | x axis title (optional) |
| ylabel   | y axis title (optional) |
| zlabel   | z axis title (optional) |
| title    | title (optional)        |
|----------+-------------------------|

#+BEGIN_SRC fortran
  call surf(X,Y,Z,xlabel,ylabel,zlabel,title)
#+END_SRC


*** scatter3D
3D scatter plot.

|----------+-------------------------|
| Variable | Description             |
|----------+-------------------------|
| x(N)     | x values                |
| y(N)     | y values                |
| z(N)     | z values                |
| xlabel   | x axis title (optional) |
| ylabel   | y axis title (optional) |
| zlabel   | z axis title (optional) |
| title    | title (optional)        |
|----------+-------------------------|

#+BEGIN_SRC fortran
 call scatter3D(X,Y,Z,xlabel,ylabel,zlabel,title)
#+END_SRC

** pythonPlots
python plotting wrappers, simply copy /pyplots.py/ into the necessary directory and use the following command.

|----------+-------------------------|
| Variable | Description             |
|----------+-------------------------|
| x(N,M)   | multi-dimensional array |
| x(N)     | x values                |
| y(N)     | y values                |
| xaxis    | x axis title (optional) |
| yaxis    | y axis title (optional) |
| legend   | legend (optional)       |
| title    | title (optional)        |
|----------+-------------------------|

#+BEGIN_SRC fortran
  call pyplot(x,title,xaxis,yaxis,legend)
  call pyplot(x,y,title,xaxis,yaxis)
#+END_SRC
